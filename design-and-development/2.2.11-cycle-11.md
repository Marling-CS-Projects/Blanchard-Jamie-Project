# 2.2.11 Cycle 11

## Design

### Objectives

I realised the main issues I wanted to fix with my code were all problems with the Chill Framework. The Chilli Framework was laggy, the window couldn't be resized (so I made it only work with 1080P screens), you couldn't close it using Alt+f4 and the frame rate scaled with the screen, so the game ran twice as fast on a 60 fps screen than it did on a 30 fps screen. I already had to modify the framework to allow transparent sprites and sprite flipping anyway, so I thought the easiest way to fix those issues would be to write my own framework.\
\
This would give me more control over the project as I knew what was going on in the entire project and could easily modify it. After some research, I found [GDI+](https://learn.microsoft.com/en-us/windows/win32/gdiplus/-gdiplus-loading-and-displaying-bitmaps-use) which is a C++ API that allows me to draw images and text on a C++ window.&#x20;

* [x] Create a window from a blank project
* [x] Import GDI+
* [x] Create a frames-per-second limiter
* [ ] Allow images to be drawn
* [ ] Allow images to be flipped

### Usability Features

*

### Key Variables

| Variable name | Use |
| ------------- | --- |
|               |     |
|               |     |
|               |     |

### Pseudocode

```
// Some code
```

## Development

### Outcome

I could follow the [Microsoft tutorial](https://learn.microsoft.com/en-us/windows/win32/gdiplus/-gdiplus-drawing-a-line-use) to create a window and initialise GDI+. I had a lot of modifications to make though, as this code only draws one image. I started by adding a frames-per-second limiter to ensure the game ran at a constant speed

{% code title="GDIPLUS.cpp" %}
```cpp
#include <chrono>

//Setup timer
typedef std::chrono::high_resolution_clock hiresclock;

while (true)
{
    //Handles client messages
    if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        if (msg.message == WM_QUIT)
            break;
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    //Handles clock
    static auto timer = hiresclock::now();
    auto milisec = (hiresclock::now() - timer).count() / 1000000;

    if (milisec > 16.666666667)
    {
        //Manages timer
        timer = hiresclock::now();
        //Main code
    }
}
```
{% endcode %}

After that I added my previous files and initialised a PaintStruct and the main loop

```cpp
PAINTSTRUCT ps;
HDC hdc = BeginPaint(hWnd, &ps);
Game game(hdc);
```

I passed hdc into game (which wasn't there before) so that I could use it to initialise Graphics.&#x20;

{% code title="CustomGraphics.cpp" %}
```cpp
CustomGraphics::CustomGraphics(HDC& hdc)
    :
    graphics(hdc),
    brush(Color(255, 0, 0, 255)),
    fontFamily(L"Times New Roman")
{
}
```
{% endcode %}

I could use my new Graphics to draw Images

```cpp
void CustomGraphics::DrawSprite(float x, float y, Image& image)
{
    graphics.DrawImage(&image, x, y);
}
```

But after trying to draw a sprite I found that after using EndPaint() (to draw the next frame), the next frame was drawn under the first one. This meant it couldn't be seen by the player. To fix this I had to change my loop to never end a paint, and clear the image before drawing again.&#x20;

This finally gave me sprites, but I then couldn't scale them or flip them. GDI has no built-in scaling, meaning I had to scale myself. To do this, I passed the client's dimensions from GDIPLUS.cpp to Game.cpp to CustomGraphics.cpp at the start of every frame so I could use them to scale the images relative to the 1920\*1080 I drew the original game at. ADD FLIP

### Challenges



## Testing

### Tests

| Test | Instructions | What I expect | What actually happens | Pass/Fail |
| ---- | ------------ | ------------- | --------------------- | --------- |
| 1    |              |               |                       | Pass      |
